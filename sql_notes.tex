\documentclass{article}
\usepackage[left=0.6in,top=0.6in,right=0.6in,bottom=0.6in]{geometry}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{parskip}
\usepackage{enumitem}
\setlist[enumerate]{leftmargin=5mm}
\setlist[itemize]{leftmargin=*, nosep}
\usepackage{amsmath,amssymb,graphicx}
\usepackage{titling} % adjust spaces for title
\usepackage{ctex}

% -- Define SQL style for listings --
\definecolor{codebackground}{rgb}{0.95, 0.95, 0.95}
\definecolor{codekeyword}{rgb}{0,0,1}
\definecolor{codecomment}{rgb}{0,0.5,0}
\definecolor{codestring}{rgb}{0.64,0.08,0.08}

\lstdefinestyle{mysql}{
	language=SQL, % Basic SQL highlighting
	gobble=5, % customize indentation
	backgroundcolor=\color{codebackground},
	basicstyle=\ttfamily\footnotesize,
	keywordstyle=\color{codekeyword}\bfseries,
	commentstyle=\color{codecomment}\itshape,
	stringstyle=\color{codestring},
	numbers=none, % no line numbers
	numberstyle=\tiny,
	stepnumber=1,
	numbersep=10pt,
	tabsize=2,
	showspaces=false,
	showstringspaces=false,
	breaklines=true,
	frame=single, % single frame around code (top, right, bottom, left)
	frameround=ffff,
	rulecolor=\color{gray!20},
	framesep=2mm
}
% Global setting to use this style for all \lstset
\lstset{style=mysql}


\title{\vspace*{-15mm} MySQL Notes}
\vspace{-8mm}
\author{Jihuan Zhang}
\vspace{-8mm}
\date{}


\begin{document}
\maketitle
\vspace{-15mm}
\section{Basic Syntax}
	\subsection{Displaying Subtables}
	
	\begin{itemize}
		\item The \texttt{\color{red}SELECT} ... \texttt{\color{red}FROM} ... statement is used to select and display data from a database.
		
		\begin{lstlisting}
			SELECT * FROM table1; -- select the entire table
			SELECT col1, col2, ... FROM table1; -- select all rows for specific columns from a table
		\end{lstlisting}
		
		\item The \texttt{\color{red}WHERE} clause is used to filter rows. Some basic logic operators are: \texttt{\color{red}AND}, \texttt{\color{red}OR}, \texttt{\color{red}NOT}, \texttt{\color{red}=} (not ``==''), \texttt{\color{red}!=}/\texttt{\color{red}<>}, \texttt{\color{red}<}, \texttt{\color{red}<=}, \texttt{\color{red}>}, \texttt{\color{red}>=}.
		
		\begin{lstlisting}
			SELECT * FROM table1 WHERE col1 <= num AND col2 = 'string1';
			SELECT * FROM table1 WHERE col1 <= col2; -- operators in sql are vectorized
		\end{lstlisting}
		
		\item \texttt{\color{red}ORDER BY} is used to order the result. Default is ascending order. Use \texttt{\color{red}ASC}/\texttt{\color{red}DESC}  to specify order.
		
		\begin{lstlisting}
			SELECT * FROM table1 ORDER BY col1; -- also works for strings in alphabetical order
			SELECT * FROM table1 ORDER BY col1 ASC; -- same as above
			SELECT * FROM table1 ORDER BY col1 DESC; -- specify descending order
			SELECT * FROM table1 ORDER BY col1, col2; -- order wrt col1, and within the same values of col1, order wrt col2
			SELECT * FROM table1 ORDER BY col1 DESC, col2 ASC, ...; -- customize the orders
		\end{lstlisting}
		
		\item \texttt{\color{red}LIMIT} and \texttt{\color{red}OFFSET} are used to restrict the number of rows to display\footnote{They are supported by SQL Server and Oracle.}.
		
		\begin{lstlisting}
			SELECT * FROM table1 ORDER BY col1 LIMIT 3; -- display the first 3 rows (ordered)
			SELECT * FROM table1 ORDER BY col1 DESC LIMIT 3; -- display the last 3 rows
			SELECT * FROM table1 ORDER BY col1 LIMIT 3 OFFSET 1; -- display the first 3 rows ignoring row 1 (i.e., rows 2-4)
			SELECT * FROM table1 ORDER BY col1 LIMIT 3;
		\end{lstlisting}
		\item \texttt{\color{red}AS} (Aliases) for subqueries and new variable name
		
		\begin{lstlisting}
			SELECT col1 AS new_name FROM (SELECT col1, col2 FROM table1 ORDER BY col3) AS new_table_name;
		\end{lstlisting}
	\end{itemize}
	
	
	
	\subsection{More on Operators}
	
	\begin{itemize}
		\item \texttt{\color{red}BETWEEN} \texttt{num1} \texttt{\color{red}AND} \texttt{num2}: $\texttt{num1}\leq\cdot\leq\texttt{num2}$. In many SQL versions, \texttt{num1} must not be greater than \texttt{num2}.
		
		\begin{lstlisting}
			SELECT * FROM table1 WHERE col1 BETWEEN 2*PI() AND SQRT(2500);
		\end{lstlisting}
		$\pi=\texttt{\color{red}PI()}$, $\sqrt{\cdot} =$ \texttt{\color{red}SQRT($\cdot$)}.
		
		\item \texttt{\color{red}LIKE} \texttt{'string'} (case-insensitive); \texttt{\color{red}LIKE BINARY} \texttt{'string'} (case-sensitive). \\
		Wildcards (通配符): \texttt{\color{red}\%} (zero or more arbitrary characters), \texttt{\color{red}\_} (one arbitrary character).
		
		\begin{lstlisting}
			SELECT * FROM table1 WHERE col1 LIKE 'a%'; -- start with 'a'
			SELECT * FROM table1 WHERE col1 LIKE '%a'; -- end with 'a'
			SELECT * FROM table1 WHERE col1 LIKE '%a%'; -- contain 'a'
			SELECT * FROM table1 WHERE col1 LIKE '_a%' -- second character is 'a'
			SELECT * FROM table1 WHERE col1 LIKE '%a_' -- second to last character is 'a'
			SELECT * FROM table1 WHERE col1 LIKE '%a_%' -- contain 'a' followed by at least one character
			SELECT * FROM table1 WHERE col1 LIKE '%_a_%' -- contain 'a' in between two characters
		\end{lstlisting}
		
		\item A space is a character in SQL.
		
		Operator presedence (运算符优先级): \texttt{\color{red}()} > everything else > \texttt{\color{red}NOT} > \texttt{\color{red}AND} > \texttt{\color{red}OR}.
		
		\item \texttt{\color{red}IN($\cdot$)}:
		
		\begin{lstlisting}
			SELECT * FROM table1 WHERE col1 IN (num1, num2, num3);
			SELECT * FROM table1 WHERE col1 = num1 OR col1 = num2 OR col1 = num3; -- equivalent
			SELECT col1 FROM table11 WHERE col2 IN (SELECT col3 FROM table2 WHERE col4 = 'string1'); -- subqueries can be used
		\end{lstlisting}
		
		\item \texttt{\color{red}IS NULL}:
		\begin{lstlisting}
			SELECT * FROM table1 WHERE col1 IS NULL;
			SELECT * FROM table1 WHERE col1 IS NULL AND col2 IS NULL;
		\end{lstlisting}
	\end{itemize}
	
	
	
	\subsection{Modifying a Table}
	
	\begin{itemize}
		\item The \texttt{\color{red} INSERT INTO} ... \texttt{\color{red}VALUES} ... statement is used to insert new rows in a table.
		
		\begin{lstlisting}
			INSERT INTO table1 VALUES (val1, val2, ...); -- insert a row of full length
			INSERT INTO table2 (col1, col2, ...) VALUES (val1, val2, ...); -- insert a sub-row
			INSERT INTO table1 VALUES (val1, val2, ...), (val1, val2, ...), ...; -- insert multiple rows
		\end{lstlisting}
		
		\item The \texttt{\color{red}UPDATE} ... \texttt{\color{red}SET} statement is used to modify the existing rows.
		
		\begin{lstlisting}
			UPDATE table1 SET col1 = val1, col2 = val2, ... WHERE condition;
		\end{lstlisting}
		
		\item The \texttt{\color{red}DELETE FROM} statement is used to delete existing rows in a table. The \texttt{\color{red}DROP TABLE} statement delete the entire table.
		
		\begin{lstlisting}
			DELETE FROM table1 WHERE condition; -- delete rows satisfying the condition
			DELETE FROM table1; -- delete all rows
			DROP TABLE table1; -- delete the table
		\end{lstlisting}
		
		\item Reverse or commit the modifications using \texttt{\color{red}BEGIN}, \texttt{\color{red}ROLLBACK}, and \texttt{\color{red}COMMIT}.
		
		\begin{lstlisting}
			BEGIN;  -- Start a transaction/modification
			
			UPDATE accounts SET balance = balance - 100 WHERE id = 1;
			UPDATE accounts SET balance = balance + 100 WHERE id = 2;
			
			-- If you change your mind:
			ROLLBACK;  -- undo both updates
			
			-- If you're sure:
			COMMIT;    -- make both updates permanent
		\end{lstlisting}
	\end{itemize}
	
	\subsection{Aggregate Functions}
	
	\begin{itemize}
		\item \texttt{\color{red}DISTINCT} finds unique values in rows; can be combined with \texttt{\color{red}COUNT()}.
		
		\begin{lstlisting}
			SELECT COUNT(*) FROM table1; -- count the number of rows
			SELECT DISTINCT col1, col2, ... FROM table1; -- select unique rows wrt (col1, col2, ...)
			SELECT COUNT(DISTINCT col1, col2, ...) FROM table1; -- count the number of unique rows wrt (col1, col2, ...)
		\end{lstlisting}
		
		\item \texttt{\color{red}COUNT()}, \texttt{\color{red}MIN()}, \texttt{\color{red}MAX()}, \texttt{\color{red}AVG()}, and \texttt{\color{red}SUM()} ignore \texttt{null} values, except for \texttt{\color{red}COUNT(*)}.
		
		\begin{lstlisting}
			SELECT MAX(col1) FROM table1 WHERE condition;
			SELECT SUM(Quantity * 10) FROM OrderDetails;
			SELECT OrderID, SUM(Quantity) AS TotalQuantity FROM OrderDetails GROUP BY OrderID;
			SELECT * FROM Products WHERE price > (SELECT AVG(price) FROM Products); -- Return all products with a price above average
		\end{lstlisting}
	\end{itemize}
	
	\subsection{Join}
	
	\begin{itemize}
		\item \texttt{\color{red}JOIN} ... \texttt{\color{red}ON} ..., or \texttt{\color{red}INNER JOIN} ... \texttt{\color{red}ON} ..., is used to select rows that have matching values in both tables. Use ``\texttt{\color{red}.}'' in \texttt{table1.col1} and \texttt{table2.col2}. \texttt{\color{red} LEFT JOIN}, \texttt{\color{red} RIGHT JOIN}, and \texttt{\color{red} FULL JOIN} are used in the same way.
		
		\begin{lstlisting}
			SELECT Orders.OrderID, Customers.CustomerName, Orders.OrderDate
			FROM Orders
			JOIN Customers ON Orders.CustomerID=Customers.CustomerID;
			
			SELECT Products.ProductID, Products.ProductName, Categories.CategoryName
			FROM (Products JOIN Categories ON Products.CategoryID = Categories.CategoryID); -- equivalent, this shows the logic of JOIN
			
			SELECT Orders.OrderID, Customers.CustomerName, Orders.OrderDate
			FROM Customers
			JOIN Orders ON Orders.CustomerID=Customers.CustomerID; -- equivalent, order of table names doesn't matter
			
			SELECT Orders.OrderID, Customers.CustomerName, Orders.OrderDate
			FROM Orders
			INNER JOIN Customers ON Orders.CustomerID=Customers.CustomerID; -- equivalent, JOIN is the same as INNER JOIN
		\end{lstlisting}
		
		Join three tables:
		\begin{lstlisting}
			SELECT Orders.OrderID, Customers.CustomerName, Shippers.ShipperName
			FROM ((Orders JOIN Customers ON Orders.CustomerID = Customers.CustomerID)
			JOIN Shippers ON Orders.ShipperID = Shippers.ShipperID);
		\end{lstlisting}
		
		\item The underlying details of \texttt{\color{red} INNER JOIN}, \texttt{\color{red} LEFT JOIN}, \texttt{\color{red} RIGHT JOIN}, and \texttt{\color{red} FULL JOIN}:\\
		
		Let the \texttt{employee} table be
		\begin{tabular}{|c|c|c|}
			ID & Name  & DeptID\\
			\hline
			1  & Alice & 10\\
			2  & Bob   & 20\\
			3  & Carol & 10\\
			4  & David & 40
		\end{tabular} and the \texttt{department} table be
		\begin{tabular}{|c|c|}
			DeptID & DeptName\\
			\hline
			10 & Sales\\
			20 & Marketing\\
			30 & IT\\
			50 & Finance
		\end{tabular} .\\
		
		Then, ``\texttt{employee JOIN department ON employee.DeptID = department.DeptID}'' creates the following table:\\
		\begin{center}
			\begin{tabular}{|c|c|c|c|c|}
				employee.ID & employee.Name  & employee.DeptID & department.DeptID & DeptID.DeptName \\
				\hline
				1  & Alice & 10 & 10 & Sales\\
				2  & Bob   & 20 & 20 & Marketing\\
				3  & Carol & 10 & 10 & Sales
			\end{tabular}
		\end{center}
		\vspace*{4mm}
		
		``\texttt{employee LEFT JOIN department ON employee.DeptID = department.DeptID}'' creates the following table:\\
		\begin{center}
			\begin{tabular}{|c|c|c|c|c|}
				employee.ID & employee.Name  & employee.DeptID & department.DeptID & DeptID.DeptName \\
				\hline
				1  & Alice & 10 & 10 & Sales\\
				2  & Bob   & 20 & 20 & Marketing\\
				NULL  & NULL & NULL & 30 & IT\\
				NULL  & NULL & NULL & 50 & Finance
			\end{tabular}
		\end{center}
		
		\vspace*{4mm}
		
		``\texttt{employee RIGHT JOIN department ON employee.DeptID = department.DeptID}'' creates the following table:\\
		\begin{center}
			\begin{tabular}{|c|c|c|c|c|}
				employee.ID & employee.Name  & employee.DeptID & department.DeptID & DeptID.DeptName \\
				\hline
				1  & Alice & 10 & 10 & Sales\\
				2  & Bob   & 20 & 20 & Marketing\\
				3  & Carol & 10 & 10 & Sales\\
				4  & David & 40 & NULL & NULL
			\end{tabular}
		\end{center}
		\vspace*{4mm}
		
		``\texttt{employee FULL JOIN department ON employee.DeptID = department.DeptID}'' creates the following table:\\
		\begin{center}
			\begin{tabular}{|c|c|c|c|c|}
				employee.ID & employee.Name  & employee.DeptID & department.DeptID & DeptID.DeptName \\
				\hline
				1  & Alice & 10 & 10 & Sales\\
				2  & Bob   & 20 & 20 & Marketing\\
				3  & Carol & 10 & 10 & Sales\\
				4  & David & 40 & NULL & NULL\\
				NULL  & NULL & NULL & 30 & IT\\
				NULL  & NULL & NULL & 50 & Finance
			\end{tabular}
		\end{center}
		\vspace*{4mm}
		
		Therefore, combined with \texttt{SELECT} ... \texttt{FROM} ..., it is easy to understand what's happening. Also, it is clear that table1 LEFT JOIN table2 is the same as table2 RIGHT JOIN table1, with the only difference be the column order.\\
		
		Now, observe that in the above example, the matching columns have unrepeated values in at least one of the two tables (in the example, Dept.ID in \texttt{department} is unrepeated). What if both have repeated values?\\
		
		When the join columns aren't unique in either table, you get a Cartesian product of the matching rows - every matching row from table1 is combined with every matching row from table2. For example, let the \texttt{department} table be
		\begin{tabular}{|c|c|}
			DeptID & DeptName\\
			\hline
			10 & Sales\\
			20 & Marketing\\
			10 & Sales
		\end{tabular} instead.\\
		
		Then, ``\texttt{employee JOIN department ON employee.DeptID = department.DeptID}'' creates the following table:\\
		\begin{center}
			\begin{tabular}{|c|c|c|c|c|}
				employee.ID & employee.Name  & employee.DeptID & department.DeptID & DeptID.DeptName \\
				\hline
				1  & Alice & 10 & 10 & Sales\\
				1  & Alice & 10 & 10 & Sales\\
				2  & Bob   & 20 & 20 & Marketing\\
				3  & Carol & 10 & 10 & Sales\\
				3  & Carol & 10 & 10 & Sales
			\end{tabular}
		\end{center}
		
	\end{itemize}
	
	
	
\section{Time Series Data}
 Create a table consisting of stock name (ticker), time (ts), and prices.
\begin{lstlisting}[gobble=1]
	CREATE TABLE stock_prices (
		ticker VARCHAR(10),
		ts TIMESTAMP,
		price DECIMAL(10,2)
		);
	
	INSERT INTO stock_prices VALUES
		('TSLA', '2025-09-01 09:30:00', 185.20),
		('TSLA', '2025-09-01 09:31:00', 185.35),
		('TSLA', '2025-09-01 09:32:00', 185.10);
	
	SELECT ts, price,
	AVG(price) OVER (ORDER BY ts ROWS 4 PRECEDING) AS moving_avg
	FROM stock_prices;
\end{lstlisting}
\end{document}